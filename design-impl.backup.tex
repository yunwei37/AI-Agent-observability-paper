\section{Design}

\subsection{Design Principles}

We propose \emph{boundary tracing} as a novel approach to AI agent observability. The key insight is that all meaningful agent interactions must traverse well-defined system boundaries: the kernel interface for system operations and the network interface for external communications. By observing at these boundaries rather than within agent code, we achieve stable, comprehensive monitoring independent of agent implementation details.

Boundary tracing leverages the principle that while agent internals may change rapidly and unpredictably, the interfaces through which agents interact with their environment remain stable. System calls, network protocols, and file system operations provide consistent observation points that persist across framework versions and agent modifications. This approach fundamentally shifts the trust model from assuming cooperative agents to enforcing observation at tamper-proof system boundaries.

The boundary tracing concept builds on three core principles. First, comprehensiveness through system-level observation ensures that all agent actions, regardless of implementation language or execution method, must interact with the operating system kernel to perform meaningful work. Second, stability through interface consistency leverages the fact that while agent frameworks evolve rapidly, system interfaces like POSIX system calls and network protocols change slowly and maintain backward compatibility. Third, semantic correlation enables understanding by capturing both what agents intend (through LLM communications) and what they do (through system operations), then correlating these perspectives to understand agent behavior holistically.

\subsection{System Architecture}

To understand boundary tracing, we first characterize the typical AI agent system architecture and identify stable observation points:

\begin{center}
\begin{Verbatim}[fontsize=\small, commandchars=\\\{\}]
┌─────────────────────────────────────────────────┐
│             System Environment                  │
│  (Operating System, Containers, Services)       │
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │      Agent Runtime Framework            │   │  ← Application Layer
│  │   (LangChain, AutoGen, Claude Code)     │   │
│  │   • Prompt orchestration                │   │
│  │   • Tool execution logic                │   │
│  │   • State management                    │   │
│  └─────────────────────────────────────────┘   │
│                    ↕                            │
│  ═══════════════════════════════════════════   │  ← Network Boundary
│           (TLS-encrypted traffic)               │     (Observable)
│                    ↕                            │
│  ┌─────────────────────────────────────────┐   │
│  │         LLM Service Provider            │   │
│  │    (OpenAI API, Local Models)           │   │
│  └─────────────────────────────────────────┘   │
│                                                 │
│  ═══════════════════════════════════════════   │  ← Kernel Boundary
│         (System calls, File I/O)                │     (Observable)
└─────────────────────────────────────────────────┘
\end{Verbatim}
\end{center}

The architecture reveals two stable observation boundaries that form the foundation of our approach. At the network boundary, all agent-LLM communications traverse the network interface as TLS-encrypted HTTP requests. Despite encryption, eBPF uprobes on SSL library functions can intercept data post-encryption at the application layer, capturing prompts, responses, and API parameters. This provides complete visibility into the semantic layer of agent reasoning. At the kernel boundary, all system interactions—process creation, file operations, network connections—must invoke kernel system calls. These syscalls provide a tamper-proof observation point that captures agent system behavior regardless of implementation language or framework.

The interaction between these boundaries enables comprehensive observability. When an agent receives a prompt through the network boundary, processes it internally, and then performs system operations through the kernel boundary, we can correlate these events to understand the complete execution flow. This dual-boundary approach captures both the "why" (agent reasoning) and the "what" (system effects) of agent behavior.

\subsection{Key Design Decisions}

Several critical design decisions shaped AgentSight's implementation of boundary tracing. The choice of eBPF over alternatives such as kernel modules or userspace hooking was driven by production requirements. eBPF provides kernel-level observation with verified safety guarantees, eliminating the stability risks of kernel modules while offering far superior performance compared to userspace approaches. The ability to dynamically load and update eBPF programs without system restarts proved essential for iterative development and production deployment.

For TLS interception, we chose to use uprobes on SSL library functions rather than network-level packet capture or HTTP proxy approaches. This decision enables us to capture decrypted data at the precise moment it exists in cleartext within the application's address space, avoiding the complexity of key management required for packet decryption or the latency and configuration overhead of proxy-based solutions. The uprobe approach works transparently with any TLS version or cipher suite, requiring no agent configuration changes.

The correlation strategy presented a fundamental challenge: how to associate high-level LLM interactions with low-level system operations across potentially different processes and time windows. We implemented a multi-signal correlation engine that considers process lineage, temporal proximity, file descriptor inheritance, and working directory context. This approach handles the common pattern where an agent process makes an LLM API call, then spawns a subprocess that performs the actual system operations based on the LLM's response.

Performance optimization guided several architectural choices. We implement aggressive filtering in eBPF programs to reduce data volume, use ring buffers for efficient kernel-to-userspace communication, and employ streaming analysis to avoid storing complete event histories. These decisions enable sub-3\% overhead even under high event rates while maintaining the semantic context necessary for behavioral analysis.


\section{Implementation}

AgentSight's implementation centers on two eBPF programs: an SSL monitoring program that uses uprobes to intercept SSL\_write/SSL\_read functions for capturing decrypted LLM communications, and a process monitoring program that tracks system calls, file operations, and process lifecycle events. The SSL monitor maintains connection state through eBPF hash maps and handles Server-Sent Events by buffering partial messages until complete, achieving sub-1\% CPU overhead through efficient ring buffer usage and configurable filtering. The process monitor combines stable tracepoints (sched\_process\_fork, sched\_process\_exit) with dynamic kprobes on system calls to capture comprehensive agent behavior. A Rust-based streaming pipeline processes these raw events through analyzers that reassemble fragmented SSL data, parse HTTP headers to identify LLM API calls, and correlate events across process boundaries using multi-signal tracking including process genealogy, temporal proximity, and shared resources.

The implementation faced three critical engineering challenges. First, TLS interception required intercepting SSL library functions across OpenSSL and BoringSSL variants without adding latency—we achieved sub-50 microsecond overhead through runtime symbol resolution and asynchronous processing. Second, Server-Sent Events from LLM providers fragment responses across hundreds of SSL\_read calls, requiring stateful reassembly with protocol-aware parsing to identify event boundaries. Third, cross-process correlation proved essential as agents spawn subprocesses that escape traditional monitoring—our correlation engine tracks process trees, temporal windows (100-500ms), file descriptor inheritance, and working directories to maintain causal relationships across boundaries, enabling semantic understanding of complete agent execution flows from initial prompts through system operations.