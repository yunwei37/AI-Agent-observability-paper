\section{Background}

\subsection{AI Agent Architecture}

AI agents represent a new class of software systems that combine language models with environmental interactions. These systems typically consist of three core components: (1) an LLM backend that provides reasoning capabilities, (2) a tool execution framework that enables system interactions, and (3) a control loop that orchestrates prompts, tool calls, and state management. Popular frameworks such as LangChain~\cite{langchain}, AutoGen~\cite{autogen}, and Claude Code implement variations of this architecture. The key characteristic distinguishing AI agents from traditional software is their ability to dynamically construct execution plans based on natural language objectives—an agent tasked with "analyze this dataset" might autonomously decide to install packages, write analysis scripts, execute them, and interpret results—all without predetermined logic paths. This flexibility comes from the LLM's ability to generate arbitrary code and command sequences.

\subsection{The Observability Challenge: A Departure from Traditional Software}

The autonomy of AI agents creates unprecedented observability challenges. Traditional Application Performance Monitoring (APM) assumes deterministic software with predefined execution paths that can be instrumented at development time. AI agents violate this assumption in three fundamental ways: \textbf{Dynamic Execution Paths} where an agent's sequence of operations emerges from LLM reasoning, not static code, making the same task solvable differently on each run and impossible to instrument all potential logic paths in advance; \textbf{Cross-Boundary Interactions} where agents frequently use tools to spawn subprocesses (\texttt{bash}, \texttt{python}), execute shell commands (\texttt{curl}, \texttt{git}), or interact with the filesystem, escaping the monitoring scope of their parent process and rendering traditional process-scoped instrumentation blind; and \textbf{The Semantic Gap} where a series of low-level system calls—like file reads and writes—is meaningless without context, requiring correlation with the agent's high-level intent locked within LLM interactions to understand whether operations constitute benign data analysis or malicious exfiltration. These fundamental differences demand a new approach to observability that can capture both the "why" (agent reasoning) and the "what" (system effects) of agent behavior.

\subsection{eBPF Technical Foundation}

eBPF (extended Berkeley Packet Filter) represents a fundamental advancement in kernel programmability, enabling safe execution of custom programs within the Linux kernel without modifying kernel source code or loading kernel modules~\cite{brendangregg}. Originally developed for packet filtering, eBPF has evolved into a general-purpose in-kernel virtual machine that powers modern observability, networking, and security tools~\cite{ebpfio,cilium}. For AI agent observability, eBPF provides unique capabilities that traditional monitoring approaches cannot match—it enables observation at the exact boundaries where agents interact with the system, capturing both high-level semantic information through TLS interception and low-level system behavior through syscall monitoring with minimal performance impact. The eBPF safety model is crucial for production deployment: the kernel verifier performs exhaustive analysis of eBPF programs before loading, ensuring memory safety through bounds-checked pointer arithmetic, proving program termination by prohibiting unbounded loops, enforcing resource limits on stack usage and execution time, and enabling type safety through BTF (BPF Type Format) for kernel version compatibility~\cite{kerneldoc}. These guarantees allow eBPF programs to run safely in production environments handling critical workloads.
